Micu Francesca-Maria 313CB
Punctaj obținut local: 95

În implementarea temei am folosit următoarele fișiere:
  structuri.h: unde au fost definite structurile și scris headerele funcțiilor
  fct.c: unde se afla functiile utilizate
  tema2.c: unde este implementat main-ul

În structuri.h sunt următoarele definiții:
  Macro-urile FAIL (folosit pentru cazul de eșec la verificări) și MAX_LEN (pentru citirea/declararea șirurilor de caractere).
  typedef struct satelit: reprezintă structura satelitul și conține o frecvență de tip întreg și un nume de lungime variabilă
  typedef int (*TFCmp)(TSatelit, TSatelit): reprezintă un pointer la funcția de comparare din heap
  typedef struct Heap: reprezintă structura de Heap și conține un nrMax de elemente posibile, un nrElem care conține numărul de elemente curent, un vector info de sateliți și o funcție comp pentru respectarea regulii din heap
  typedef struct nod: reprezintă implementarea de arbore și conține info despre un satelit și doi pointeri de tip nod spre nodul stâng și drept
  typedef struct celula: reprezintă structura de listă simplu inlănțuită care va fi folosită in implementarea cozii și conține info despre un arbore și pointer urm spre următoarea celulă
  typedef struct coada: reprezintă structura de coadă și conține doi pointeri de tip listă inc și sf.


În fișierul tema2.c se realizează: 
  Se deschid fișierele de citire și scriere obținute din argumentele 2 și 3 din linia de comandă, se rețin în inp_file și out_file și se fac verificările în caz de eșec. Se declară arborele arb și se apelează funcția ImplemArb() care creează arborele. Pentru a vedea ce task trebuie executat se verifică argumentul 1 din linia de comandă cu cu toate flag-urile posibile. La final, se inchid fișierele și se eliberează memoria ocupată de arbore. 

În fct.c sunt definite următoarele funcții
  THeap *AlocHeap(int nrMax, TFCmp comp): Se bazează pe funcția de eliberare de arbore de la laborator. Se alocă heap, alături de vectorul de sateliți, se completează nrMax de elemente, se setează la 0 nrElem (numărul curent de elemente) și se actualizează câmpul care primește funcția.
  void ElibNodArb(TArb arb): Se bazează pe funcția de eliberare de arbore de la laborator. Dacă arborele/subarborele există se apelează eliberarea pentru nodul stâng și drept, urmând după să se elibereze numele din info și nodul propriu-zis.
  void ELibArb(TArb *a): Se bazează pe funcția de eliberare de arbore de la laborator. Dacă arborele nu a fost deja eliberat se apelează eliberarea nodurilor din arbore. La final, arborele se seteaza la NULL.
  void ElibHeap(THeap **heap): Se bazează pe funcția de eliberare de heap de la laborator. Se parcurge vectorul de sateliți și se eliberează memoria pentru fiecare nume. După se eliberează vectorul și heap-ul, care e după setat la NULL.
  void ElibCoada(TCoada **c): Se bazează pe funcția de eliberare de heap de la curs. Se parcurge coada cu ajutorul pointerului list și se eliberează memoria pentru fiecare celulă. După se eliberează coada și se setează la NULL.
  int RelMinHeap(TSatelit a, TSatelit b): Verifică condiția de min heap. Dacă frecvențele sunt diferite se returnează diferența lor, altfel se returnează rezultatul obținut prin compararea numelor.
  TArb ImplemArb(FILE *inp_file): În șirul de caractere lin se citește din fișier linie cu linie, la început numărul de sateliți convertit cu atoi(). Se alocă min_heap folosind funcția specifică de alocare și se citesc sateliții din fișier. În variabila satelit se rețin datele extrase din fișier și se alocă dinamic numele, urmând după să fie adăugat satelitul în min_heap folosind funcția InserHeap(). La final, se apelează funcția care realizează arborele după min_heap ConstrArb() și se eliberează memoria alocată.
  TSatelit ExtrHeap(THeap *h): Se bazează pe funcția de extragere din heap de la labprator. Se verifică dacă heap-ul există și conține elemente, iar în caz de eșec se returnează un satelit gol cu frecvența -1. Se salvează primul element din vector (rădăcina heap-ului) în val apoi se înlocuiește cu ultimul element și se decrementează numărul de elemente. Se parcurge heap-ul pentru a asigura în continuare proprietatea de min heap, comparând nodurile părinte cu copiii lor. În parcurgere, se identifică nodul de interschimbat verificând dacă fiii stâng sau drept au valoarea mai mică decât nodul curent. Se realizează interschimbarea cu fiul de valoare mai mică și se continuă procesul de verificare pornind de la noul nod. La final, funcția returnează valoarea minimă extrasă din heap.
  TArb ConstrArb(THeap *min_heap, int nr_sateliti): Se inițializează un arbore gol și un vector temporar pentru a stoca arborii intermediari. În bucla principală, se extrage cei doi sateliți cu frecvențele cele mai mici din heap, se creează un satelit de legătură cu frecvența calculată ca sumă și numele concatenat. Verifică existența nodurilor în arborele curent utilizând funcția CautaSat() și dacă nodurile nu au fost găsite în arbore se salvează arborele curent in vectorul de arbori pentru a nu pierde legăturile de arbore. Se construiesc noduri noi pentru sateliții minimi care nu sunt deja în arbore. Verifică dacă nodurile alocate se află în vectorul de arbori temporari pentru a nu aloca același nod de mai multe ori. Leagă nodurile corespunzătoare sateliților la nodul de legătură ca fii stâng și drept și actualizează arborele curent. La final, eliberează memoria temporară și returnează arborele complet.
  void Task1(TArb arb, FILE *out_file): Se bazează pe algoritmul tip BFS explicat la curs în pseudocod și afișează arborele pe nivel. Alocă și inițializează o coadă pentru parcurgere, inserând rădăcina arborelui în aceasta. Parcurge arborele nivel cu nivel, determinând numărul de noduri de pe fiecare nivel prin funcția NumarNodCoada(). Pentru fiecare nod de pe nivel, extrage nodul din coadă, afișează frecvența și numele satelitului și adaugă spațiu dacă nu este ultimul nod de pe nivel. Inserează în coadă copiii nodului dacă există. După ce termină un nivel complet, adaugă un caracter newline pentru separarea nivelurilor. La final, eliberează memoria alocată pentru coadă.
  void Task2(FILE *inp_file, FILE *out_file, TArb arb): Se citește numărul de linii codificate din fișier și parcurge fiecare linie, eliminând caracterul newline. Pentru fiecare linie, se parcurg caracterele codificării și se deplasează în arbore conform valorii citite: la stânga pentru '0' și la dreapta pentru '1'. Când ajunge la o frunză, se afișează numele satelitului găsit și se resetează poziția în arbore la rădăcină pentru restul decodificării. După terminarea decodificării unei linii complete, se adaugă newline.
  void Task3(FILE *inp_file, FILE *out_file, TArb arb): Se citește din fișier numărul de sateliți care trebuie codificați și se citesc sateliții din fișier. Pentru fiecare satelit, se elimină newline-ul din numele citit și inițializează un șir de caractere care va memora codificarea. Se apelează funcția CodifArb() care construiește codificarea. Se verifică dacă codificarea a fost generată cu succes și o afișează în fișierul de ieșire.
  char *CodifArb(TArb arb, char *codif, char *nume_sat, int idx_codif): Se verifică dacă arborele este gol, caz în care returnează NULL. Compară apoi numele satelitului curent cu cel căutat pentru a vedea dacă s-a ajuns la nodul căutat, caz în care adaugă terminatorul de șir la poziția curentă din codif și returnează codificarea completă. Se adaugă un '0' în codif când parcurge subarborele stâng și un '1' când parcurge subarborele drept (dacă există surarborii respectivi), incrementând indexul pentru următoarea poziție din șir. Funcția folosește un fel de backtracking, ignorând ramurile care nu duc la satelitul căutat.
  void Task4(FILE *inp_file, FILE *out_file, TArb arb): Se citește din fișier numărul de sateliți și se alocă un vector de șiruri de caractere pentru stocarea numelor acestora. Apoi, se parcurge fișierul de intrare, citind numele fiecărui satelit, eliminând newline-ul și alocând memorie corespunzătoare pentru fiecare nume în parte. Se apelează funcția CautaSatComun() pentru a identifica cel mai apropiat părinte comun al sateliților și scrie rezultatul în fișierul de ieșire. La final, eliberează corect întreaga memorie alocată pentru vectorul de nume și pentru citirea datelor.
  char *CautaSatComun(char **nume_sat, int nr_sat_caut, TArb arb): Se verifică dacă arborele este gol și returnează NULL în acest caz. Pentru fiecare nod, verifică dacă subarborele curent conține toate numele de sateliți căutate, folosind funcția auxiliară CautaNumeSat(). Dacă toți sateliții sunt găsiți în subarborele curent, continuă căutarea mai întâi în subarborele stâng și apoi în subarborele drept, pentru a găsi nodul cel mai apropiat care conține toți sateliții. Când nu mai poate găsi un subarbore mai adânc care să conțină toți sateliții, returnează numele nodului curent ca fiind părintele comun.
  int NumarNodCoada(TCoada *c): Se parcurge lista de la început până la final, incrementând contorul nr pentru fiecare nod din listă.
  TArb ExtrCoada(TCoada *c): Funcția se bazează pe funcția de extragere a unui nod din coadă predată la curs. Se verifică dacă există elemente în coadă și returnează NULL în caz contrar. Pentru extragere se salvează pointerul către primul element al listei și informația acestuia (arborele stocat). Actualizează începutul cozii la următorul element și se verifică dacă s-a golit coada după extragere, caz în care actualizează și sfârșitul cozii la NULL. Se eliberează memoria ocupată de celula extrasă și returnează informația din celulă.
  void InserCoada(TCoada *c, TArb arb): Funcția se bazează pe funcția de extragere a unui nod din coadă predată la curs. Se alocă memorie pentru o nouă celulă, se verifică succesul alocării și se inițializează câmpurile celulei cu informația primită și NULL pentru câmpul următor. Dacă coadă este goală începutul și sfârșitul listei pointează spre aux, altfel elementul de după sfârșitul listei devine aux și se actualizează sfârșitul listei cu aux.
  TArb ConstrNod(TSatelit sat): Se bazează pe funcția de construire a unui nod în arbore predată la laborator. Se alocă memorie pentru un nod, verificând rezultatul alocării și returnând NULL în caz de eșec. Se inițializează frecvența din nod cu valoarea din satelitul primit ca parametru și se alocă memorie pentru numele satelitului. Se verifică dacă alocarea pentru nume a reușit, iar în caz contrar, eliberează memoria deja alocată pentru nod și returnează NULL. Apoi, se copiază numele satelitului în noul nod utilizând funcția strcpy() și se inițializează explicit pointerii către subarborii stâng și drept cu NULL, asigurând astfel că nodurile nou create sunt inițial frunze.
  void InserHeap(THeap *heap, TSatelit val): Funcția se bazează pe funcția de inserare în heap implementată la laborator. Se verifică inițial dacă heap-ul a atins capacitatea maximă (numărul de elemente este egal cu numărul maxim alocat), realizând în acest caz o realocare prin incrementarea capacității maxime și realocarea vectorului de sateliți. După realocare, verifică succesul operației. Se inserează noul satelit la sfârșitul vectorului și incrementează contorul de elemente, apoi îl deplasează în vector pentru a menține proprietatea de heap minim. La deplasare, se compară satelitul nou cu părintele său utilizând funcția de comparare a heap-ului și realizează interschimbări succesive până când ajunge în poziția corectă sau la rădăcina heap-ului.