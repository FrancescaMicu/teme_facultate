Micu Francesca-Maria 313CB
Punctaj obținut local: 120

În implementarea temei am folosit următoarele fișiere:
  structuri.h: unde au fost definite structurile și scris headerele funcțiilor
  fct.c: unde se afla functiile utilizate
  tema1.c: unde este implementat main-ul

În structuri.h sunt următoarele definiții:
  Macro-urile MAX_LEN (utilizat în citirea din fișier și ca lungimea maximă  a șirurilor de caractere: operația citită din fișier, descrierea si url-ul paginii, etc) și FAIL (folosit în cazurile de eșec ale funcțiilor și main).
  typedef struct page: reprezintă pagina care conține un id (număr întreg), un url (tip șir de caractere de maxim 50 de caractere) și o descriere (tip șir de caractere de dimensiune variabilă).
  typedef struct tab: reprezintă tabul care conține un id (număr întreg), un currentPage (pointer spre pagina curentă) și backwardStack și forwardStack (doua stive).
  typedef struct browser: reprezintă browserul care conține current (pointer spre tabul curent) și list_2_inl (listă dublu înlănțuită circulară cu santinelă).
  typedef struct stack: reprezintă stiva care conține info (pointer spre o pagină) și urm (pointer spre următoarea celulă). Stiva este implementată ca o listă simplu înlănțuită și am folosit structura predată la curs.
  typedef struct tabsList: reprezintă lista de taburi care conține info (pointer spre un tab) și pre, respectiv urm (pointeri spre celula anterioară, respectiv următoare din listă). Am utilizat structura de listă predată la curs.

În fct.c sunt definite următoarele funcții:
Alocări:
  TPage *AlocPag(int id, char* url, char* descr): se alocă o pagină cu detaliile specificate în parametrii funcției. După alocarea paginii se introduc datele respective id-ului, url-ului și se alocă spațiul necesar pentru descriere, urmând să se introducă în câmpul respectiv. Se fac verificările necesare după fiecare alocare (în caz de eșec se fac eliberările necesare de memorie) și se returnează pagina.
  TPage *CreatePag_0(): se alocă spațiu pentru pagina implicită. În variabilele id, url și descr se introduc datele necesare primei pagini și se apelează funcția AlocPag() cu parametrii respectivi. Se face verificarea necesară dupa alocare și se returnează pagina.
  TTab *AlocTab(int id, TPage *curr_page): se alocă un tab cu detaliile specificate în parametrii funcției. După declararea și alocarea tabului, câmpurile sale se actualizează cu parametrii funcției (id și curr_page). Stivele backwardStack și forwardStack se setează la NULL. La final se returnează tabul.
  TTab *CreateTab_0(): alocarea tabului implicit specific browserului.vSe declară câmpurile specifice tabului implicit, folosindu-se de parametrul pag_0 pentru pointarea spre pagina implicită și funcția AlocTab() apelată cu parametrii creați anterior. După alocarea de memorie se face verificărea necesară și în caz că aceasta eșuează se returnează NULL. La final, se întoarce tabul implicit.
  TListTab AlocLista(): alocarea listei dublu înlănțuite circulare cu santinelă. Se utilizează funcția predată la curs care constă în declararea și alocarea listei care pointeaza spre santinelă. Dacă alocarea eșuează se returnează NULL. La final, santinela pointează spre ea însăși, câmpul info este lăsat la NULL și se returnează lista.
  TListTab AlocNodLista(TTab *tab, TListTab list): se alocă un nod nou în listă. Se utilizează funcția predată la curs care constă în alocarea nodului și testarea reușitei sale, inițializarea câmpului info cu tab primit ca parametru și cu crearea unor legături care fac nodul să pointeze spre santinelă. Aceste legături vor fi corectate în funcțiile în care se folosește această funcție ajutătoare. La final, se returneaza nodul.
  TBrow *AlocBrowser(): se aloca browserul. După declararea și alocarea browserului se alocă tabul curent care va fi tabul implicit, deci se folosește funcția CreateTab_0(). Se alocă lista folosind funcția ALocLista(). În lista se pune primul nod care va fi cel cu informația reprezentată de tabul implicit obținut prin folosirea funcției AlocNodLista(). După se adaugă nodul în listă legându-l de santinelă și refăcând legăturile (nodul nou pointează spre santinelă și santinela spre noul nod). După fiecare alocare de memorie se fac verificările necesare și în caz de eșec se eliberează memoria deja alocată și se întoarce NULL. La final se returnează browserul.

Funcții ajutătoare:
  int ALocNodStiva(TStiva *stiva, TPage *pag): reprezintă implementarea funcției push caracteristică stivei și se bazează pe funcția predată la curs. Se alocă un nod nou și după ce se verifică reușita se adaugă informația dată ca parametru (pag), se leagă noul nod de stivă și se modifică începutul stivei astfel încât aceasta să pornească de la noul nod adăugat (principiul specific stivei). În caz de reușită se returnează 1 și în caz contrar 0.
  int ExtragNodStiva(TStiva *stiva, TPage **pag): reprezintă implementarea funcției pop caracteristică stivei și se bazează pe funcția predată la curs. Se testează dacă stiva e goală și în caz contrar se extrage nodul din vârful stivei (principiu caracteristic stivei) astfel: se reține în pag transmis ca parametru informația din primul nod din stivă și stiva trece să pointeze spre următorul nod din stivă. Se eliberează memoria pentru nodul extras și, la final, se returnează 1 în caz de reușită a funcției și 0 în caz contrar.
  void AfisStivaInv(TStiva stiva, FILE *out_file): realizează afișarea stivei în ordine inversă (de la bază la vârf). Se verfică dacă stiva a ajuns la final, afișarea oprindu-se în acel moment. Altfel, se reapelează funcția cu următorul nod din stivă și se afișeaza url-ul paginii reținute în nod.

Eliberări de memorie:
  void ElibStiva(TStiva *stiva): eliberează memoria alocată pentru o stivă primită ca parametru. Se bazează pe funcția de eliberare a stivei predată la curs. Se verifică în caz că stiva a fost deja eliberată și în caz contrar se parcurge stiva și utilizând un nod de tip stivă declarat înainte care primește nodul stivă de la momentul respectiv, se eliberează memoria specifică nodului spre care pointează atunci și stiva trece la următorul nod. La final, stiva se setează pe NULL.
  void ElibLista(TListTab *lista): eliberează memoria alocată pentru o listă dublu înlănțuită circulară cu santinelă primită ca parametru. Se verifică inițial ca lista să nu fie deja goală și se declară un nod care să pointeze spre nodul următor santinelei pentru a parcurge lista. În parcurgerea listei, un nod aux declarat anterior pointează spre nodul respectiv al listei și îl eliberează (alături de memoria ocupată de tabul din câmpul info în caz că nu a fost alocată deja). La final, se eliberează santinela și se setează la NULL. 
  void ElibPag(TPage **pag): eliberează memoria alocată pentru o pagină primită ca parametru. Se verifică în caz că pagina există și în acest caz se eliberează memoria pentru descriere (dacă nu a fost eliberată deja) și pentru pagina propriu-zisă. La final, descrierea și pagina se setează spre NULL.
  void ElibTab(TTab **tab): eliberează memoria alocată pentru un tab primit ca parametru. Se verifică în caz că tabul există și în acest caz se elibereaza memoria pentru pagina (daca e alocata), pentru cele două stive (backward și forward dacă au fost alocate) și pentru tab. La final, acestea se setează pe NULL.
  void ElibBrow(TBrow **brow): eliberează memoria alocată pentru un browser primit ca parametru. Se verifică în caz că browserul există și în acest caz se elibereaza memoria pentru listă (dacă nu a fost eliberată deja) și pentru browser. La final, acestea se setează pe NULL.

Toate verificările făcute la începutul funcțiilor de eliberare de memorie pentru a vedea dacă elementul respectiv e deja gol au scopul de a asigurara că nu întâmpin erori de tip double free.

Funcții care rezolvă task-urile propriu-zis:
  void NEW_TAB(TBrow *brow, int *tab_id_curr, TPage *pag_0): rezolvarea task-ului NEW_TAB. Se incrementează varibila tab_id_curr care conține id-ul ultimului tab adăugat în listă (care a fost sau nu închis). Se crează tabul cu parametrii de pagină implicită (parametrul pag_0) și un id (nou_tab_id) folosindu-se de funcția AlocTab(). Se crează un nod cu informația din tabul nou creat utilizând funcția AlocNodLista() și se leagă nodul de ultimul nod din lista de taburi. Browserul curent va pointa spre tabul nou creat. După fiecare alocare de memorie se verifică funcționalitatea ei și se eliberează memoria deja alocată în caz de eșec.
  void PRINT(TBrow *brow, FILE *out_file): rezolvarea task-ului PRINT. Se afișează id-ul tabului curent specific browserului. În variabila lista se reține primul nod din listă (cel de după santinelă), se verifică dacă lista nu conține doar santinela și în acest caz se va mai afișa doar la final descrierea. Altfel, se parcurge lista de la primul tab până la tabul curent și după de la tabul curent la restul. Se fac verificările necesare în caz că se ajunge la santinlă să treacă peste ea. La final, se afișează descrierea paginii curente din tabul curent.
  void CLOSE(TBrow *brow, FILE *out_file): rezolvarea task-ului CLOSE. Lista este un pointer la primul nod din listă cu ajutorul caruia parcurgem lista până se ajunge la nodul cu tabul curent al browserului. Dacă nodul cu tabul găsit este tabul inițial se afișează mesajul de eroare. În caz contrar, se șterge nodul refăcându-se legăturile din listă, eliberând tabul și nodul.
  void OPEN(TBrow *brow, char *id, FILE *out_file): rezolvarea task-ului OPEN. În parametrul id se află numărului id-ului tabului care trebuie deschis și în variabila id_cautat se reține acest id convertit din char în int cu funcția atoi(). În variabila tab_cautat se va reține un pointer spre tabul căutat și cu lista vom parcurge lista până la santinelă. Dacă se găsește tabul căutat se reține pointer spre el și dacă nu, se întoarce mesajul de eroare. La final, se modifică tabul curent din browser cu cel obținut în urma parcurgerii.
  void NEXT(TBrow *brow): rezolvarea task-ului NEXT. Cu variabila lista care reține pointer spre listă se parcurge aceasta până cand se ajunge la tabul curent al browserului. Lista trece la următorul nod și verifică dacă s-a ajuns la santinelă, în acest caz înaintând încă o dată. La final, se modifică tabul curent al browserului cu tabul nou identificat.
  void PREV(TBrow *brow): rezolvarea task-ului PREV. Asemănător ca la funcția anterioară, cu variabila lista parcurgem lista până se ajunge la nodul cu tabul curent și trecem la tabul anterior. În caz că se ajunge la santinelă se mai merge o dată la tabul anterior. La final, se modifică tabul curent din browser cu cel obținut în urma parcurgerii.
  void PAGE(TBrow *brow, char *id, TPage **pag, int nr_pag, FILE *out_file): rezolvarea task-ului PAGE. Se verifică dacă există vectorul de pagini sau dacă există doar o singură pagină în acesta (pagina implicită). În id se află id-ul paginii care trebui deschise și în id_pag se convertește id-ul din chiar în int cu funcția atoi(). Variabila pag_caut se folosește pe rol de flag în parcurgerea vectorului de pagini, iar în caz că se găsește pagina cu id-ul căutat devine 1 și se reține poziția paginii în vector în variabila idx_pag_cautat. Dacă pagina nu se găsește se returnează mesaj de eroare, altfel se alocă pagina curentă browserului în stiva Backward a tabului curent din browser, se eliberează stiva Forward și se setează pagina curentă a tabului curent la noua pagină găsită.
  void PRINT_HISTORY(TBrow *brow, FILE *out_file, char *id): rezolvarea task-ului PRINT_HISTORY. În id se află id-ul tabului căutat și în id_cautat se convertește acest id din char în int folosind funcția atoi(). Se parcurge lista de taburi până când se găsește tabul căutat și se salvează un pointer către acesta în tab_cautat. Dacă nu se găsește tabul se întoarce mesajul de eroare. Se afișează url-urile din stiva Forward cu funcția AfisStivInv(), url-ul paginii curente din tabul curent și url-urile din stiva Backward parcurgând stiva de la vârf la bază.
  void BACKWARD(TBrow *brow, FILE *out_file): rezolvarea task-ului BACKWARD. Dacă stiva Backward e goală se afișează mesajul de eroare. Altfel, se adaugă pagina curentă în stiva Forward și se reține pointer către ea în variabila pag_ant. La final, se resetează pagona curentă a tabului curent cu pagina extrasă.
  void FORWARD(TBrow *brow, FILE *out_file): rezolvarea task-ului FORWARD. Asemănător, ca la funcția de dinainte, se verifică dacă stiva Forward e goală și în caz contrar se afișează mesajul de eroare. Se adaugă pagina curentă a tabului curentă în stiva Backward, se extrage ultima pagină din stiva Forward și se reține pointer către ea în variabila pag_urm. La final, se resetează pagina curentă a tabului curent cu pagina extrasă.

În fișierul tema1.c se realizează:
  Se deschid fișierele de input și de output cu perimisiune de citire/scriere text în variabilele inp_file și out_file și se verifică reușita acestora, returnându-se mesaj de eroare în caz negativ (și se face ieșirea din main cu -1). 
  În nr_pag se citește din fișier numărul de pagini care urmează sa fie citite și se incrementează pentru a adăuga și pagina implicită. Se declară și se alocă un vector de pagini (de tip TPage** în care se vor reține paginile din fișier, un vector de pointeri) și se returnează mesaj de eroare în caz de eșec (și se face ieșirea din main cu -1) . Cu ajutorul funcției CreatePag_0() se alocă pagina implicită și se afișează mesaj de eroare în caz de eșec. Acest pointer spre pagina implicită va fi folosit mereu în funcții unde trebuie alocat un tab (a cărui pagină curentă trebuie setată la pagina implicită) pentru a nu aloca mereu o nouă pagină implicită care nu mai poate fi dupa eliberată. Dacă se citesc pagini din fișier (nr_pag>1) se declară id, url și descr (ultimele 2 de maxim 50 de caractere). Se parcurge vectorul de pagini, se citesc id-ul, url-ul și descrierea paginiilor din fișier, pune NULL pe ultimul caracter (în loc de newline) și se alocă în pagina respectivă din vector foloind funcția AlocPag(). În caz de eroare la alocare se afișează mesajul de eroare (și se face ieșirea din main cu -1) și se eliberază memoria deja alocată. Urmează alocarea browserului și afișarea erorilor, eliberarea memoriei și ieșirea din main în cazul nereușitei.
  În variabila tab_id_curr se va reține id-ul utlimului tab deschis chiar dacă acesta a fost închis ulterior. În nr_oper se citesc numărul de operații și e alocat dinamic oper de tip char în care se vor reține operațiile citite din fișier. În caz de eroare de alocare, se eliberează memoria deja alocată, se afișază mesajul de eroare și se iese din main cu -1. În oper se citește înainte de a se intra în for pentru a elimina linia goală rămasă după citirea cu fscanf. 
  În for se citește operația din fișier, se elimina caracterul de newline și prin multiple comparații de strstr() între ce s-a citit din fișier și numele posibilelor operații, se intră pe o ramură a if-urilor (else if-urilor). În if-uri/else if-uri se apelează funcția corespunzătoare operației citite din fișier, iar pentru OPEN, PAGE și PRINT_HISTORY se reține în variabila id id-ul citit alături de operația respectivă. În aceste cazuri se face strtok de 2 ori pentru id cu scopul de a scăpa de spațiul dintre comandă și id. 
  La finalul codului, se închid fișierele și se eliberează memoria alocată pentru oper, fiecare pagină în parte, vectorul de pagini și browser prin apelare funcțiilor de eliberare ale memoriei ElibPag() și ElibBrow(). 