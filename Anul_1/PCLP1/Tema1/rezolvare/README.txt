În fct.c am creat următoarele funcții: 
  aloc_dinamic(): Primeste ca parametru o matrice si o aloca corespunzator, iar in caz de eroare la alocare întoarce un mesaj corespunzător.
  free_mem(): Eliberează memoria pe care o ocupa matricea primită ca parametru.
  copy_mat(): Se copiaza matricea "mat_cpy" in matricea "mat_paste"
  rotire_col(): Se permută circular la dreapta coloana dată ca parametru "col" cu un număr de poziții "nr_poz"
  calc_win(): Se determina numărul de combinații câștigătoare din cadran în variabila "count_win". Pe fiecare line se calculează lungimea subșirului maximal și dacă este cel puțin 3 crește variabila de câștig. Am determinat prima dată condiția pentru diagonalele de forma [(1, i), (2, i + 1), (3, i + 2)] și, dacă sunt egale, am, verificat și daca se formeaza un X cu acea diagonală, în caz afirmativ diagonala opusă care formeaza X-ul devenin -1 pentru a nu fi considerată din nou. Dacă se îndeplinește una dintre aceste condiții crește contorul de căștig. Pentru diagonalele de forma [(3, i), (2, i + 1), (1, i + 2)]
am folosit un algoritm asemănător, dar nu am mai căutat X-uri. La final, se returneaza numărul de câștiguri găsite.
  calc_scor(): Funcția folosește scheletul funcției calc_win(), dar se mai adaugă câteva condiții pentru calcularea scorului. Dacă se găsește o linie câștigătoare scorul crește cu lungimea subșirului. Un X găsit primește valoarea 21, iar o diagonală simpla câștigătoare are valoarea 7. În cazul în care oricare dintre cazurile precedente valoarea elementelor linie/diagonalei/X-ului este 7, scorul respectiv se dubleaza. La final, se alocă dinamic un vector de frecvență care determină numărul de valori distincte din cadran. Dacă numărul este cel puțin 4 se adaugă 15 la scor, altfel dacă este cel puțin 2 scorul crește cu 100.


în main.c: Am citit numarul taskului, numarul de linii si coloane, am alocat dinamic matricea și apoi am citit-o.
  În funcție de numărul taskului citit de la tastatură se intră pe o ramificație diferită a sistemului de if-else if corespunzatoare taskului respectiv.

Task 1: Se citește indexul culoanei și numărul de poziții cu care trebuie rotită matricea. Pentru efectuarea rotiriilor am apelat functia rotire_col cu parametrii adecvați. La final, am afisat matricea rezultată în urma rotirii.

Task 2: Am declarat și alocat dinamic cu funcția aloc_dinamic() o nouă matrice "matrice_calc_scor". Noua matrice primește valorile elementelor matricei citite de la tastatură folosind funcția copy_mat(). Așadar, afișăm numărul de combinații câștigătoare și scorul respectiv apelând funcțiile calc_win și calc_scor, prima cu matricea matrice și cea de a doua cu "matr_calc_scor". Utilizăm matricea nou creată deoarece în funcțiile calc_win și calc_scor se modifică matricea inițială și pentru a nu primi un rezultat eronat în consecință. După eliberăm memoria ocupată de "matr_calc_scor".

Task 3: Se citește numărul de operații(variabila T). Declarăm o matrice nouă "mat_rot" servind același scop ca noua matrice de la taskul 2. O alocăm doar cu 3 linii pentru a lucra doar pe cadran și a optimiza. În for citim coloana care trebuie rotită(col) și numărul de poziții pentru aceasta(rot) și o rotim cu funcția rotire_col(). Copiem matricea rotită in noua matrice(mat_rot), îi calculăm scorul și adunăm rezultatul la calculul final(variabila inițializată la inceput "score_of_all" în care se calculează câștigurile totale). Apoi afișăm rezultatul și eliberăm memoria noii matrice.

Task 4: În variabila "scor_maxim" vom păstra valoarea maximă a scorului, dar acum reștine un număr cât mai mic, negativ, reprezentat de macro-ul MIN. Declarăm o matrice nouă "mat_verif" servind același scop ca noua matrice de la taskul 2. O alocăm doar cu 3 linii pentru a lucra doar pe cadran și a optimiza. Verificăm pentru fiecare poziție a cadranului matricei scorul obținut prin înlocuirea acestuia cu toate cifrele, pe rând. Copiem în "mat_verif" "matrice" cu funcția copy_mat() de fiecare dată pentru a folosi mereu matricea inițială fără modificări. Calculăm scorul obținut prin înlocuirea unui element al matricei cum am explicat mai sus, cu funcția calc_scor(). "scor_verif" reține scorul intermediar și verifică dacă nu este cumva un scor maxim. La final, afișam scorul maxim obținut și eliberăm memoria ocupată de "mat_verif" cu funcția free_mem().

Task 5: În variabila "scor_maxim" vom păstra valoarea maximă a scorului, dar acum reștine un număr cât mai mic, negativ, reprezentat de macro-ul MIN. Declarăm o matrice nouă "mat_dublu_rot" servind același scop ca noua matrice de la taskul 2. Algoritmul rotește câte două coloane cu un număr de poziții luat prin încercări repetate pentru a descoperi scorul maxim care se poate obține.  Variabilele din primele for-uri "rot_col_1" și "rot_col_2" păstrează indicii fiecăror două coloane care urmează a fi rotite. Celălalte două variabile "nr_poz_rot_1" si "nr_poz_rot_2" rețin numărul de poziții cu care urmează a fi rotite coloanele alese anterior. Se copiaza matricea noua cu functia copy_mat(), se rotesc cele două coloane alese cu rotire_col() și se calculează scorul astfel obținut în "scor_verif" cu funcția calc_scor(). Se verifică dacă noul scor nu e cumva maxim. La final, afișam scorul maxim obținut și eliberăm memoria ocupată de "mat_dublu_rot" cu funcția free_mem().

Task 6: Alocăm dinamic vectorii "dx" și "dy" care vor reține pozițiile de deplasare. Inițializăm și alocăm o nouă matrice "matr_cost" cu funcția aloc_dinamic(), care va reține drumurile de cost minim din cadranul matricei inițiale. La început elementele noii matrice primesc valoarea macro-ului MAX, doar primul element devine dupa 0, de la el începând calculele costurilor. Pentru fiecare element al matricei deteminăm pozițiile spre care putem să ne deplasăm cu ajutorul vectorilor de direcție "dx" și "dy". Verificăm daca noile coordonate ("lin_nou" și "col_nou") ne sunt accesibile (nu ies din cadranul matricei). În caz afirmativ, determinăm costul până în acel punct (variabila "new_cost", reprezentând valoarea drumului până în acel punct adunat cu diferența în modul dintre valoarea elementului de pe acea matrice și valoarea elementului de pe prima poziție a matricei, diferența aceasta fiind reținută în variabila "cost_posib") și verificăm dacă este mai mic decât costul inițial de pe acea poziție. După terminarea for-urilor afișăm valoarea elementului "matr_cost[2][M - 1]", reprezentând drumul de cost minim căutat. Apoi, se fac eliberările de memorie ale matricei matr_cost cu free_mem() și ale vectorilor "dx" și "dy".

  La final, am eliberat memoria matricei inițiale folosind funcția free_mem().

