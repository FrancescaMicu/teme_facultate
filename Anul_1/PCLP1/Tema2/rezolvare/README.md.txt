Taskul 1: Am verificat dacă coordonatele primite sunt valide(se află în dimensiunile chunkului) și în caz afirmativ am umplut blockul respectiv.

Taskul 2: Am făcut funcțiile minim și maxim care determină minimul și maximul dintre două elemente. Le-am folosit pentru a afla minimul și maximul dintre cele două triplete de coordonate primite, luate două câte două și le reține în variabile cu nume sugestive. În cele 3 for-uri se parcurge chunkul între limitele maxime și minime determinate mai sus și cu ajutorul funcției de la taskul 1 verifică coordonatele nu depășesc limitele, apoi umple blockul.

Taskul 3: În cele 3 for-uri se parcurge chunkul și se calculeaza distanța dintre blockul respectiv și centrul sferei, folosind formula determinării normei. Se verifică dacă distanța calculată este mai mică decât raza sferei, iar în caz afirmativ se umple blockul respectiv.

Taskul 4: Am declarat și alocat dinamic un nou chunk(chunk_new) care memoreaza valorile chunkului inițial. Trebuie lucrat pe un nou chunk pentru a nu ca valorile noi introduse să nu fie luate ca target_block-uri mai târziu. Am declarat trei vectori de direcții(dx, dy, dz) care memoreaza direcțile în care se va putea face învelirea(am încercat să îi aloc dinamic, dar aveam prea multe erori de magic numbers). În primele trei for-uri am lucrat pe noul chunk și am verificat ca blockul să respecte cerința și în caz afirmativ am luat înca un for care parcurge cei trei vectori de direcție, verifica dacă noul block determinat de direcție, care e parte a învelirii, este accesibil și , daca este, primește valoarea dată. La final, vechiul chunk primește valorile celui nou și cel din urmă este eliberat.

Taskul 5: Am creat o nouă funcție care parcurge în mod recursiv matricea. Funcția recursivă verifică dacă coordonatele sunt în interiorul chunkului și dacă blockul respectiv este cel dorit și, în caz afirmativ, se apelează funcția de 4 ori(corespunzător direcților de a merge înainte, înapoi, la stânga sau la dreapta) și se tot repetă procesul. În funcția inițială am inițializat variabila want_block care reține tipul blockului primit de la parametrii funcției și după este apelată funcția recursivă unde se folosește varibila declarată pentru a determina restul blockurilor de același tip ca cel cerut.

Taskul 6: Folosind un algoritm asemănător ca la taskul anterior, am creat o nouă funcție care parcurge recursiv matricea, dar de data asta se deplaseaza și în sus și jos în funcție de coordonata y.

Taskul 7: Am alocat o nouă matrice tridimensionala cu noile dimensiuni numită chunk_rot. În chunk_rot se reține matricea rotită, prin schimbarea axei x a lui chunk_rot cu axa z(indexul i devine depth - (k+1)). La final, eliberam memoria corespunzătoare matricei inițiale. 

Taskul 8: Am alocat o nouă matrice tridimensională(chunk_new de tip int deoarece pot exista chunkuri cu mai mult de 255 de corpuri cum este și la testul 3, marcajul avănd și valori negative) în care vor fi marcate corpurile din chunk. Cu variabila falls se va determina dacă corpurile au ajuns cât de jos puteau sau nu , iar cu ajutorul variabilei max_y voi determina new_height. În primul while, rețin în chunk_new valorile inițiale ale lui chunk și determin corpurile sortate după tipul blockului, corpurile fiind marcate după variabila mark_find_corp care crește după ce găsesște un corp. Pentru aceasta, am creat funcția fill_corp funcționează asemănător cu funcția de la taskul 6 și marcheaza corpul găsit. În funcția let_it_fall, parcurg corpurile și determin numărul de blockuri pe care îl coboară fiecare block din corp (până cănd dă de un block care nu e aer sau care nu e de același tip ca el), reținând minimul de blockuri coborăte în min_down. Se parcurge din nou chunk_new și cobor fiecare block din corp cu min_down poziții. În variabila max_y determin nivelul cel mai de sus pe care se găsește un block și falls devine 1 daca corpul coboară. În următorul while procedez asemănător, dar nu se mai ține cont de tipul blockului când se marcheaza din nou corpurile, fiind considerate corpuri acum doar blockurile adiacente(acest lucru se realizeză în funcția fill_new_corp). După ce sunt marcate noile corpuri este apelată din nou funcția let_it_fall care va realiza căderea corpurilor. Cele două while-uri se execută până când toate corpurile au fost coborâte. Noua înălțime este determinată ca fiind max_y +1. După am fost eliberările și realocăriile necesare.

Taskul 9: Am alocat vectorul flat în care am retinut toate elementele din chunk. Am alocat vectorul runs în care urmează să fie stocată matricea compresată. În parcugerea vectorului flat am determinat numărul de blockuri de acelasi tip alaturate retinut in variabila count_near. Pe primii doi biti ai elementelor din vector am reținut tipul blockului, apoi am procesat restul bițiilor în funcție de valoarea lui count_near. Dacă count_near e mai mic de 32 se reține pe urmatorul bit 0, dacă e mai mare de 32 dar totusi mai mic de 4095 am actualizat următorii 2 biți cu 1 și 0. În ultimul caz, am actualizat elemente din vectorul runs(punând tipul blockului, 10 pe următorii biți si valoarea lui 4095 pe următorii) până când rămân mai puțin de 4095 de valori in count_near. Ce rămâne se stochează, după caz, ca în primele două cazuri.

Taskul 10: Am alocat matricea tridiminensională chunk unde va fi chunkul decompresat.Se parcurge vectorul code și se reține în variabila curr_block tipul blockului curent. Programul reține în variabila nr_block numărul de e elemente a fiecărui run în funcție de cele 3 cazuri de la taskul 9(pt cazul 2 și 3 se adaugă la nr_block și elementele corespunzătoare din următoarele run-uri). Apoi se reține în matricea chunk (folosind indexii prestabiliști de la început idx_i, idx_j, idx_k) blockurile pe pozițiile corespunzatoare, indexii fiind dupa updatați după caz(când id_i sau id_k ajung la final, sunt reinițializați și o iau de la început).