Task 1:
    secretariat *citeste_secretariat: Am declarat un pointer de tip secretariat(date_sec) si l-am alocat dinamic. După se citește fișierul primit cs parametru. Se reține fiecare linie din text pe rând în variabila date. Începem cu alocarea tipul studenți și tai împart cu strtok(cu delimitatori ", ") pentru a reține câmpurile necesare pe care după le adresez structurii date_sec tip studenti. Aloc studenții până ajung la linia de MATERII unde aloc materiile asemănător, dar numele materiei și al titularului sunt alocate dinamic cu strdup(la finalul variabilei nume_complet se pune un spațiu la final care trebuie eliminat). Când ajung la linia ÎNROLĂRI incepe alocarea tipului înrolări asemănător ca mai sus. Pentru determinarea mediei generale, rețin în timpul alocărilor înrolăriilor, pentru id-ul fiecărui student suma notelor de la materia respectivă pe care o adaug în câmpul de medie generală a studentului respectiv. La final, parcurg studenții și împart suma calculată la numărul materiilor la care este înrolat studentul.
 
    adauga_student: Am reținut în variabila i nr de studenți pe care l-am folosit drept contor și după am crescut nr de studenți cu unul.    Apoi se copiază în câmpurile structurii, pe noua poziție a vecorului de structuri student, valorile corespunzătoare variabilelor id,     nume, an_studiu, statut, media generală (pentru nume am folosit memcpy în loc de strcpy pt că îmi dădea erori de coding style).
    
    elibereaza_secretariat: Prima dată se eliberează vectorul de studenți, nefiind necesare și alte eliberări în cadrul său. După, într-un vector care parcuge materiile se eliberează câmpul aferent numelui și numelui_titularului fiecărei materii în parte, ca apoi să se poată elibera vectorulde materii. La final, eliberăm vectorul de înrolări și secretariatul, pe care îl la după NULL pentru a nu a mai putea fi accesat după. 

Task 2: Am creat fișierele auxiliare (fct_aux_task2) în care sunt păstrate funcțiile auxiliare pe care le-am folosit la taskul2.
    int conditie_stud(secretariat *s, char *camp, char *operator_cond, char *valoare , int i): Funcție pentru determinarea condiției din comandă corespunzătoare tabelei de studenți. Verific pentru fiecare camp din structura student dacă corespunde cu variabila camp, după determin operatorul folosit prin comparații și în funcție de operator și de camp se returneaza valoarea de adevăr a condiției.

    int conditie_mat(secretariat *s, char *camp, char *operator_cond, char *valoare, int i): Funcție pentru determinarea condiției din comandă corespunzătoarea tabelei de materii. Principiul de funcționare este asemănător ca la funcția de dinainte.

    int conditie_inrol(secretariat *s, char *camp, char *operator_cond, char *valoare, int i): Funcție pentru determinarea condiției din comandă corespunzătoarea tabelei de înrolări. Principiul de funcționare este asemănător ca la funcția de dinainte.

    void interog_simpla(secretariat *s, char **camp, char *tabel, int nr_camp): Funcție folosită pentru implementarea SELECT fără filtrării. Se determină tabelul din care trebuie afișate după, se parcuge vectorul de cuvinte camp și se determină ,prin comparații ce câmpuri din tabelă trebuie afișate, în total fiind nr_camp câmpuri în vectorul de cuvinte. În cazul în care variabila camp conține caracterul * se afișsază toate câmpurile din tabel. În cazul în care mai sunt câmpuri care trebuie afișate, printăm un spațiu și, la final newline.

    void interog_filtr_simplu(secretariat *s, char **camp, char *tabel, char *camp_filtru, char *operator_cond, char *valoare, int nr_camp): Funcție folosită pentru implementarea SELECT cu filtrare simplă. Principiul este asemănător ca la interog_simpla, doar că inainte de a verifica pentru fiecare student, materie, respectiv înrolare campurile, se verifică dacă se respectă condiția pentru instanța respectivă, prin apelarea primelor 3 funcții cu variabilele camp_filtru, operator_cond, valoare.

    void interog_filtr_compl(secretariat *s, char **camp, char *tabel, char *camp_filtru1, char *operator1, char *valoare1, char *camp_filtru2, char *operator2, char *valoare2, int nr_camp):  Funcție folosită pentru implementarea SELECT cu filtrare complexă. Asemănator ca la interog_filtr_simplu doar că se verifică două condiții prin apelarea primelor 3 funcții cu variabilele camp_filtru1, operator1, valoare1 respectiv, camp_filtru2, operator2, valoare2.

    void update_filtr_simplu(secretariat *s, char *tabel, char *camp, char *valoare, char *camp_cond, char *operator_cond, char *valoare_cond): Funcție folosită pentru implementarea UPDATE cu filtrare simplă. Se determină tabela în care trebuie aduse modificări și se verifică dacă instanța respectivă respectă condiția(prin apelare funcțiilor de condiție cu variabilele camp_cond, operator_cond, valoare_cond). În caz afirmativ, se compară valoarea variabilei camp cu toate câmpurile din tabel și când se găsește câmpul respectiv, se modifică cu valoare.

    void update_filtr_compl(secretariat *s, char *tabel, char *camp, char *valoare, char *camp_cond1, char *operator_cond1, char *valoare_cond1, char *camp_cond2, char *operator_cond2, char *valoare_cond2): Funcție folosită pentru implementarea UPDATE cu filtrare complexă. Principiul este asemănător ca la funcția de dinainate doar că se verifică două condiții înainte de verificarea câmpului care trebuie modificat, cu variabilele camp_cond1, operator_cond1, valoare_cond1 respectiv, camp_cond2, operator_cond2, valoare_cond2.

    float calc_medie(secretariat *s, int poz_stud): Funcție pentru recalcularea mediei generale după anumite modificari ale secretariatului. Se recalculează suma tuturor notelor studentului de pe poziția poz_stud și se recalculează nr materiilor la care este înrolat. Se determină media brută prin împărțirea celor două, se reține în val_aprox numărul împreună cu primele 3 zecimale ca un întreg. Verific dacă ultima cifră a acestui număr este cel puțin 4(nu am verificat cu 5 pentru a îmi lua o marjă de eroare din cauza modului în care este calculat val_aprox) și în caz afirmativ crește val_aprox cu 1 și se recalculează media. Se verifică cazul particular în care numărul de materii este 0, caz în care media devine 0.

    secretariat* update_note(secretariat *s, char *camp, char *cuv): Funcție pentru implementarea UPDATE în cazul în care câmoul care trebuie modificat este cel de note. Determin în note1, note2 și note3 notele din comandă și în cuv rețin cuvintele neimportante. Petru început rețin prima condiție și dacă nu mai există cuvinte după(dacă e singura condiție) șterg ";". Parcug înrolările și dacă găsesc una care respectă condiția modic notele cu notele calculate mai sus. După parcurg studenții și pentru studentul cu același id ca id_student al înrolării respective îi recalculez media cu funcția calc_medie. Asemănător dacă mai este încă o condiție pe lângă cea principală.

    void delete_filtr_simplu(secretariat *s, char *tabel, char *camp_cond, char *operator_cond, char *valoare_cond): Funcție pentru implementarea DELETE cu filtrare simplă. Determin tabela, verific condiția cu variabilele camp_cond, operator_cond, valoare_cond și în caz afirmativ, șterg elementul de pe poziția respectivă și ajustez numărul de instanțe. În cazul în care lucrez pe tabela materii eliberez memoria pentru nume și nume_titular. Dacă șterg un element din tabela de materii sau de înrolări, parcurg studenții și recalculez mediile generale ale acestora apelând funcțua calc_media. 

    void delete_filtr_compl(secretariat *s, char *tabel, char *camp_cond1, char *operator_cond1, char *valoare_cond1,
    char *camp_cond2, char *operator_cond2, char *valoare_cond2): Funcție pentru implementarea DELETE cu filtrare complexă. Asemănător ca la funcția de dinainte doar că se verifică două condiții cu variabilele camp_cond1, operator_cond1, valoare_cond1 respectiv, camp_cond2, operator_cond2, valoare_cond2.

    în main: Inițializez variabila de tip secretariat date_sec pentru care aplez funcția de la taskul 1 citeste_secretariat. Se citește de la tastatură nr_comand(numărul de comenzi) și într-un for citesc comezile, pe rând, în variabila comanda pentru care șterg newline-ul de la sfârșit. În count_camp determin numărul de câmpuri din comandă prin numărarea virgulelor și încep sa împart comanda în cuvinte cu ajuotorul pointerului cuv. 
        Dacă primul cuvânt este SELECT determin în vectorul de cuvinte campuri toate câmpurile care trebuie afișate. După determin tabelul  în care trebuie lucrat și verifc dacă nu mai sunt cuvinte după acesta, iar dacă nu mai sunt apelez funcția interog_simpla. Dacă mai gasește o condiție după tabel se reține camp1, operator1 și valoarea1 după care apelez funcția interog_filtr_simplu. Dacă se mai gasește încă o condiție se reține în camp2, operator2, valoare2 și se apeleaza interog_filtr_compl. În fiecare dintre aceste cazuri, se șterge din ultimul cuvânt caracterul ";" , dacă există.

        Dacă primul cuvânt este UPDATE, se reține tabelul și câmpul care se va modifica. Verific dacă camp este note, iar în caz afirmativ apelez funcția update_note. Daca camp este nume sau nume_titular rețin în variabile separate nume și prenume și le șterg ghilimelele pe care după le unesc în nume_complate și i-o atribui pointerului valoare. Dacă nu, determin valoarea pe care o va primi câmpul cu strtok. După, se determină prima condiție și dacă e singura se apelează update_filtr_simplu. Dacă mai este o condiție se rețin câmpurile necesare și se apeleaza update_filtr_compl. Se aplică același principiu de ștergere a ghilimelelor ca la SELECT.

        Dacă primul cuvânt este DELETE, se determină tabelul și prima condiție în variabilele camp_cond1, operator_cond1, valoare_cond1 și dacă e singura condiție se apelează delete_filtr_simplu. În cazul în care se mai găsesc cuvinte după, rețin în camp_cond2, operator_cond2, valoare_cond2 următoarea condiție și apelez funcția delete_filtr_compl. În fiecare dintre aceste cazuri, se șterge din ultimul cuvânt caracterul ";" , dacă există.

        La final, eliberez memoria pentru fiecare dintre câmpurile variabilei date_sec și pentru variabila memorie.
Task 3: Am definit urmatoarele funcții:

XOR: Am alocat vectorul de char xor_apl în care va fi reținut rezultatul final. Cu un for în care parcurg toate caracterele dn bloc aplic xor octet cu octet între octetul respectiv din octet și apl primit ca argument(care va fi ori iv ori blocul de dinaintea celui curent, după caz). Pentru a repeta iv-ul dacă acesta nu are lungimea necesară, facem xor-ul cu al nr_octetului % lungime_iv octet, astfel când se termină iv-ul o va lua de la capăt cu octeții.

S_BOX: Asemănător ca la funcția XOR, doar că key nu este primit ca argument de tip char*, astfel definim o altă variabilă key_str de tip char* care va reține cheia în formatul necesar. Am alocat s_box_apl care va reține rezultatul după operația xor. Apoi, se face operația xor ca la funcția de dinainte.

P_BOX: Am definit vectorul mark în care se va reține dacă octetul respectiv a fost interschimbat deja sau nu. Se parcurge cu un for blocul și în variabila j se aplică formula dată. Se verfică dacă acea poziție a fost marcată și dacă nu se marchează și se face interschimbarea între poziția inițială și cea nouă determinată.

În funcția de criptare, am alocat vectorul de octeti stud și după l-am inițializat cu vectorul de studenti secreatariat->studenti de tip char* și în dim_all_blocks am determinat dimensiunea totală a vectorului care este sizeof(student) * numărul de studenti. După am făcut padding prin adăugarea octetului 0 până dimensiunea devine divizibilă cu 4. Am alocat matricea de octeti blocks(4 blocuri fiecare cu dim_block octeti) și după am inițializat fiecare bloc din cele 4 cu locația sa necesară din vectorul stud. Am alocat și blocks_enc unde se va reține criptarea fiecărui bloc. Într-un for care parcurge blocurile, am verificat dacă blocul e 0 și în caza afirmativ am apelat funcția XOR cu argumentele necesare(apl devine (char*)iv) și dacă nu se face XOR între blocul curent și blocul anterior criptat, apoi am apleat funcțile S_BOX și P_BOX cu blocul criptat obținu din operațiile efectuate înaintea operației curente. Am deschis fișierul, am scris în el blocurile criptate, am închis fișierul și am făcut eliberările de memorie necesare.(Am comentat return NULL deoarece imi dadea warning)

