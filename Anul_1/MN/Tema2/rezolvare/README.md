Micu Francesca-Maria 313CB
Tema 2 Metode Numerice
Punctaj local: 100

Task 1 - Numerical Music

streo_to_mono.m: Pentru fiecare element i din semnal, funcția calculează media aritmetică a valorilor din toate canalele, conform formulei din enunț. Această medie este implementată eficient folosind funcția mean pe dimensiunea canalelor. După, semnalul rezultat este normalizat prin împărțirea la valoarea maximă absolută. Pentru implementarea acestei funcții am folosit funcția mean despre care m-am documentat din: https://www.mathworks.com/help/matlab/ref/double.mean.html

spectogram.m: Se determină numărul de ferestre exact din semnal folosind funcția floor. Se inițializează matricea spectrogramei și pentru fiecare fereastră se extrag eșantioanele corespunzătoare din semnal. Apoi, se aplică o funcția hanning pentru "netezirea" marginilor ferestrei în transformata Fourier. Pentru fiecare fereastră procesată, se calculează transformata Fourier cu o rezoluție dublă față de dimensiunea ferestrei, păstrându-se doar prima jumătate a rezultatului (eliminând partea conjugată). Rezultatul în modul al transformatei este stocată în matricea spectrogramei. La final, se calculează vectorii de frecvență și timp cu formulele din cerință. Pentru implementarea acestei funcții am folosit funcțiile hanning și fft despre care m-am documentat din: https://www.mathworks.com/help/signal/ref/hann.html și https://www.mathworks.com/help/matlab/ref/fft.html

COMENTAREA REZULTATELOR

"Plain Sound" comparat cu "Plain Loop": Sunetul "Plain Sound" arată mai organizat față de "Plain Loop" cu linii orizontale clare reprezentând note distincte. Acest lucru se întâmplă pentru că sunetul generat conține frecvențe sinusoidale, în timp ce loop-ul conține sunete complexe cu multe armonice.

"High Pass Sound" vs "Plain Sound": "High Pass Sound" nu are frecvențe joase, rămânând vizibile doar componentele de frecvență înaltă. De aceea partea de jos a spectrogramei apare goală, iar sunetul rezultat apare mai ascuțit.

"Reverb Sound" vs "Plain Sound": "Reverb Sound" lungește sunetul față de "Plain Sound". În spectrogramă, acest lucru se vede prin faptul că liniile orizontale se estompează treptat. Acest lucru imită ecoul.

oscilator.m: Inițial se inițializează vectorul de timp. Metoda utilizează colon (:) pentru a genera un vector care conține exact punctele de eșantionare necesare, cu o distanță precisă de 1/fs secunde între ele. Alte metode alternative (precum linspace sau (0:nr_esant-1)/fs) introduc erori de rotunjire. Apoi se trunchiază exact la nr_esant (fs*dur). Am aflat despre această metodă de inițiașizare de vector din https://www.mathworks.com/help/matlab/ref/double.colon.html. Se determină numărul de timpi pentru attack, decay, release și sustain și după se inițializează vectorii specifici fiecărei componente cum este descris în cerință folosind funcția linespace. La final, se concatenează toate in matricea de envelope ASDR și se inmulțește la unda de sinus (calculată conform formulei din teorie) rezultând unda sinusoidală. În implementarea acestei funcții m-am documentat despre funcția linepace din https://octave.sourceforge.io/octave/function/linspace.html.

high_pass.m: Se calculează vectorul de frecvențe pentru prima jumătate a spectrului folosind formula f = (i-1) * fs/n. Pentru a identifica ce frecvențe trebuie eliminate, se calculează rezoluția în frecvență (rezol = fs/n). Folosind această rezoluție, se convertește frecvența de tăiere din Hz în indexul bin-ului corespunzător prin formula cutoff = round(cutoff_freq/rezol). Se inițializează un vector de mască cu zerouri. Valorile de 1 sunt setate pentru bin-urile între cutoff+1 și n-cutoff, reprezentând frecvențele înalte. Se aplică masca prin înmulțirea element cu element cu transformata Fourier a semnalului. Semnalul filtrat este obținut prin transformata Fourier inversă și normalizat.

apply_reverb: Impulsul este convertit în mono folosind funcția stereo_to_mono. Apoi, se calculează convoluția dintre semnal și răspunsul la impuls folosind fftconv, pentru a simula efectul de reverb. La final, semnalul rezultat este normalizat. În realizarea acestei funcții am folosit funcția fftconv despre care m-am documentat din https://octave.sourceforge.io/octave/function/fftconv.html.

Task 2 - Robotzii

parse_data.m: Se deschide fișierul pentru citire folosind fopen (cu permisiuni de citire text). Apoi, se citește prima linie care conține numărul de coloane n pentru vectorii X și y. Funcția citește a doua și a treia linie din fișier, care conțin cele n+1 elementele ale vectorilor coloana x și y, utilizând funcția str2num pentru a converti șirurile de caractere în valori numerice. La final, fișierul este închis. Pentru implementarea acestei funcții am folosit funcțiile de manipulare a fișierelor și conversie a datelor, despre care m-am documentat din: https://www.mathworks.com/help/matlab/ref/fopen.html, https://www.mathworks.com/help/matlab/ref/fgetl.html și https://www.mathworks.com/help/matlab/ref/str2num.html.

spline_c2.m: Se determină numărul de intervale n din lungimea vectorului x și se inițializează matricea A și vectorul b pentru sistemul de ecuații. Se completează matricea cu ecuațiile corespunzătoare valorilor funcției în punctele de interpolare. Se adaugă ecuația pentru ultimul punct prin setarea coeficienților corespunzători. Pentru continuitatea funcției la nodurile interioare, se adaugă n-1 ecuații. Asemănător, se asigură continuitatea derivatei întâi prin adăugarea a n-1 ecuații. Se asigură continuitatea derivatei a doua prin adăugarea a n-1 ecuații. În cele din urmă se adaugă condiții de frontieră naturale. Toate formulele se bazează pe cele descrise în secțiunea teoretică și în comentarii. Se rezolvă sistemul liniar A·coef = b folosind operatorul backslash (). Pentru implementarea acestei funcții m-am documentat despre spline-uri cubice din https://en.wikipedia.org/wiki/Spline_interpolation și https://www.mathworks.com/help/matlab/ref/spline.html.

P_spline.m: Se inițializează vectorul coloană y_interp cu zerouri, care va conține valorile interpolate. Pentru fiecare punct de interpolare, se caută intervalul în care se află punctul respectiv, verificând dacă x_interp(i) este între x(j) și x(j+1). Când a fost găsit intervalul, se extrag coeficienții corespunzători polinomului din acel interval din vectorul coef. Se calculează distanța xi de la punctul de bază x(j) la punctul de interpolare x_interp(i). Se evaluează polinomul în punctul respectiv și se reține rezultatul în vectorul y_interp. După găsirea intervalului corect, se iese din bucla de căutare pentru a trece la următorul punct de interpolare. Pentru implementarea acestei funcții m-am documentat despre evaluarea polinoamelor de interpolare din https://www.geeksforgeeks.org/cubic-spline-interpolation/.

vandermonde.m: Se determină numărul de puncte n din lungimea vectorului x. Se inițializează matricea Vandermonde V cu zerouri. Pentru fiecare element al matricei, se calculează V(i,j) = x(i)^(j-1), construind astfel matricea caracteristică a sistemului. Prima coloană a matricei este completată cu valoarea 1. La final, se rezolvă sistemul liniar pentru a determina vectorul de coeficienți ai polinomului de interpolare.

P_vandermonde.m: Se determină numărul de coeficienți din vectorul coef și numărul de puncte din vectorul x_interp. Se inițializează vectorul y_interp care va conține valorile polinomului în punctele de interpolare. Se atribuie mai întâi coeficientul liber tuturor elementelor din y_interp, corespunzător termenului constant al polinomului. Pentru fiecare punct de interpolare, se parcurg toți coeficienții începând cu al doilea și se adaugă la suma parțială termenul format din produsul coeficientului înmulțit cu punctul la puterea respectivă.

Task 3 - Recommendations

read_mat.m: După deschiderea fișierului, se citește linia de header pentru a determina numărul de coloane. Pentru fiecare linie următoare, funcția împarte linia după delimitatorului "," folosind funcția strsplit(), ignorând prima coloană corespunzătoare id-ului  și convertește restul valorilor în numere folosind funcția str2double(). Se adaugă elementele linie cu linie în matrice, aceasta redimensionându-se de fiecare dată. La final, fișierul este închis corespunzător. Pentru implementarea acestei funcții am folosit funcții de citire din fișier si prelucrare de șiruri din care m-am documentat din: https://octave.sourceforge.io/octave/function/strsplit.html, https://octave.sourceforge.io/octave/function/str2double.html,  https://octave.sourceforge.io/octave/function/fgetl.html.

preprocess.m: Algoritmul parcurge matricea linie cu linie, calculând pentru fiecare utilizator numărul de review-uri valide. Dacă numărul determinat este sub pragul min_reviews, linia respectivă este eliminată prin mutarea tuturor liniilor de mai jos cu o poziție în sus. La final, matricea se redimensionează doar cu liniile valide.

cosine_similarity.m: Se calculează similaritatea cosinus între doi vectori coloane A și B folosind formula din suportul teoretic, în care se transpune vectorul A pentru înmulțire.

recommendations.m: După citirea din fișier și preprocesarea matricei (folosind funcțile deja implementate), se aplică SVD pentru a extrage caracteristicile principale din datele utilizatorilor. Pentru fiecare temă (în afară de tema preferată), se calculează similaritatea cosinus între vectorul temei respective și vectorul temei preferate folosind funcția cosine_similarity. Temele sunt apoi sortate în ordine descrescătoare după similaritate și se returnează primele num_recoms teme ca recomandări. Pentru implementarea acestei funcții am folosit funcția sort despre care m-am documentat din: https://www.mathworks.com/help/matlab/ref/double.sort.html